# Vue.js

While **role-baker** doesn’t provide specific utilities for frameworks like Vue.js, it delivers the most important functionality through the `hasPermission` function. This function checks whether a user has the necessary permissions for a particular resource and action, and it can be easily integrated into Vue.js to provide permission-based rendering and route protection.

In Vue.js, we can leverage this function by creating custom utilities like **directives** and **route guards**. These utilities enable developers to implement permission-based rendering and navigation, ensuring that users can only access certain content or routes based on their roles.

## 1. **Permission Directive** for Access Control

In Vue, we can create a **custom directive** that checks the user’s permissions and conditionally renders parts of the template based on the result.

### Permission Directive

```typescript
import { DirectiveBinding } from "vue";
import { hasPermission, MyResourceConfig } from "../access-control"; // Adjust path as needed
import { useStore } from "vuex"; // Assuming you're using Vuex for state management

interface PermissionDirectiveInput<
  R extends keyof MyResourceConfig["resources"]
> {
  resource: R;
  action: MyResourceConfig["resources"][R]["action"];
  data?: MyResourceConfig["resources"][R]["dataType"];
}

export default {
  beforeMount(el: HTMLElement, binding: DirectiveBinding) {
    const store = useStore();
    const { resource, action, data } =
      binding.value as PermissionDirectiveInput<any>;
    const user = store.state.auth.user;

    if (!user || !hasPermission(user, resource, action, data)) {
      el.style.display = "none"; // Hide element if no permission
    }
  },
  updated(el: HTMLElement, binding: DirectiveBinding) {
    const store = useStore();
    const { resource, action, data } =
      binding.value as PermissionDirectiveInput<any>;
    const user = store.state.auth.user;

    if (!user || !hasPermission(user, resource, action, data)) {
      el.style.display = "none"; // Re-check permissions on updates
    } else {
      el.style.display = ""; // Show element if permission is granted
    }
  },
};
```

### Example Usage in a Template:

```html
<template>
  <div v-check-permission="{ resource: 'todos', action: 'read' }">
    <!-- This content will only be shown if the user has permission to read todos -->
    <p>{{ todoData.title }}</p>
  </div>
</template>

<script lang="ts">
  import { defineComponent } from "vue";
  import PermissionDirective from "./directives/permission-directive"; // Adjust the path

  export default defineComponent({
    directives: {
      checkPermission: PermissionDirective,
    },
    data() {
      return {
        todoData: {
          title: "Todo Item",
        },
      };
    },
  });
</script>
```

---

## 2. **Permission Guard** for Route Protection

In Vue, we can use **Vue Router** along with a custom **route guard** to ensure that users cannot navigate to a route unless they have the necessary permissions.

### Route Guard

```typescript
import { createRouter, createWebHistory, RouteRecordRaw } from "vue-router";
import { hasPermission, MyResourceConfig } from "../access-control"; // Adjust path as needed
import { useStore } from "vuex"; // Assuming you're using Vuex for state management

const store = useStore();

const checkPermissionGuard = <R extends keyof MyResourceConfig["resources"]>(
  resource: R,
  action: MyResourceConfig["resources"][R]["action"],
  data?: MyResourceConfig["resources"][R]["dataType"]
) => {
  return (to: any, from: any, next: any) => {
    const user = store.state.auth.user;
    if (!user || !hasPermission(user, resource, action, data)) {
      next("/403"); // Redirect to a 403 error page if permission is denied
    } else {
      next(); // Allow navigation if permission is granted
    }
  };
};

const routes: RouteRecordRaw[] = [
  {
    path: "/todo",
    component: () => import("./components/TodoComponent.vue"),
    beforeEnter: checkPermissionGuard("todos", "read"),
  },
  {
    path: "/403",
    component: () => import("./components/Forbidden.vue"),
  },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;
```

### Example Usage in a Vue Component:

```vue
<template>
  <div>
    <h1>Todo List</h1>
    <!-- This will only be rendered if the user has permission -->
    <ul>
      <li v-for="todo in todos" :key="todo.id">{{ todo.title }}</li>
    </ul>
  </div>
</template>

<script lang="ts">
import { defineComponent } from "vue";

export default defineComponent({
  data() {
    return {
      todos: [
        { id: 1, title: "Learn Vue.js" },
        { id: 2, title: "Learn TypeScript" },
      ],
    };
  },
});
</script>
```

---

## Explanation:

- **`hasPermission` Check**: Both the **Permission Directive** and **Route Guard** rely on the `hasPermission` function from **role-baker** to check if the user has the required permission for the specified resource and action.
- **Conditional Rendering**: The **Permission Directive** ensures that only authorized content is rendered within the template. If the user doesn't have permission, the content is hidden.
- **Route Protection**: The **Route Guard** works with **Vue Router** to restrict access to specific routes based on user permissions. If the user doesn’t have the right permission, they are redirected to a **403 Forbidden** page.

These utilities integrate seamlessly with Vue.js to enforce role-based access control in your application.
